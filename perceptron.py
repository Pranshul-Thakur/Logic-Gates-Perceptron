# -*- coding: utf-8 -*-
"""Perceptron.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1H7rqTyHkr5bLq_v0eRbn3jnBpILDV8Zm

# Logic Gate Classifier #

Classifiying 5 basic and 2 derived logic gates using Neural Networks (excluding NOT).

Following are the logic gates currently being tested :
*   AND
*   OR
*   NAND
*   NOR
*   XOR
*   XNOR
*   NOT

AND, OR, NAND, NOR can be classified using Single Perceptron (neural network with no hidden layer).

XOR, XNOR can be classified using MLP (multi layer Perceptron).

NOT requires a single neuron.

# Input Sequence #

1.   Give the input for both input state A and B in the form of an array
2.   Selecting the desired logic function

# Output Sequence #

1.   Returns the desired output for given input and selected logic function
"""

import numpy as np

single_test_cases = [
    np.array([0,0]),
    np.array([0,1]),
    np.array([1,0]),
    np.array([1,1])
 ]

multi_bit_test_cases = np.array([
    [0, 0, 1],
    [1, 1, 0],
    [1, 1, 1],
    [0, 1, 1]
])

def logic(v):
    if v >= 0:
        return 1
    else:
        return 0

def perceptronmodel(x, w, b):
    v = np.dot(w, x) + b
    y = logic(v)
    return y

def AND(x):
  w = np.array([1, 1])
  b = -1.5
  return perceptronmodel(x, w,b)

def NOT(x):
    w = -1
    b = 0.5
    return perceptronmodel(x, w, b)

def OR(x):
    w = np.array([1, 1])
    b = -0.5
    return perceptronmodel(x, w, b)

def NAND(x):
    return NOT(AND(x))

def NOR(x):
    return NOT(OR(x))

def Multi_bit_AND(x):
    x = np.atleast_1d(x)
    w = np.ones(x.shape[0])
    b = -(x.shape[0] - 0.5)
    return perceptronmodel(x, w, b)

def Multi_bit_OR(x):
    x = np.atleast_1d(x)
    w = np.ones(x.shape[0])
    b = -0.5
    return perceptronmodel(x, w, b)

def Multi_bit_NAND(x):
    return NOT(Multi_bit_AND(x))

def Multi_bit_NOR(x):
    return NOT(Multi_bit_OR(x))

def XOR(x):
  y1 = AND(x)
  y2 = OR(x)
  y3 = NOT(y1)
  return AND(np.array([y2,y3]).T)


def XNOR(x):
    y1 = OR(x)
    y2 = AND(x)
    y3 = NOT(y1)
    return OR(np.array([y2,y3]).T)

single_logicgates = [AND,OR,NAND,NOR,XOR,XNOR]

multi_bit_gates = [Multi_bit_AND, Multi_bit_OR, Multi_bit_NAND, Multi_bit_NOR]

for i in single_logicgates:
    print("\nLogic Gate :", i.__name__)
    for j in single_test_cases:
        print("({}, {}) = {}".format(j[0], j[1], i(j)))

print("\nLogic Gate : NOT")
for j in [0, 1]:
    print("({}) = {}".format(j, NOT(np.array(j))))

for i in multi_bit_gates:
    print("\nMulti Logic Gates :", i.__name__)
    for j in multi_bit_test_cases:
        print("{} = {}".format(j, i(j)))

